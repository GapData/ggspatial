# sp plotting in ggplot

.guess_epsg <- function(bbox) {
  # copied from prettymapr scalebar function
  extents <- c(bbox[1,1], bbox[1, 2], bbox[2,1], bbox[2,2])
  #check for valid lat/lon in extents
  if(extents[1] >= -180 &&
     extents[1] <= 180 &&
     extents[2] >= -180 &&
     extents[2] <= 180 &&
     extents[3] >= -90 &&
     extents[3] <= 90 &&
     extents[4] >= -90 &&
     extents[4 <= 90]) {
    warning("Autodetect projection: assuming lat/lon (epsg 4326)")
    return(4326)
  } else {
    #else assume google mercator used by {OpenStreetMap} (epsg 3857)
    warning("Audotdetect projection: assuming Google Mercator (epsg 3857)")
    return(3857)
  }
}

# stat to transform coordinates
StatProject <- ggplot2::ggproto("StatProject", ggplot2::Stat,

  compute_group = function(data, scales, crsfrom=NULL, crsto=NULL) {

    rgdal::CRSargs(sp::CRS("+init=epsg:3857")) #hack to load rgdal namespace
    if(is.null(crsfrom) || is.na(rgdal::CRSargs(crsfrom))) {
      warning("Assuming input data is lat/lon (epsg:4326)")
      crsfrom <- sp::CRS("+init=epsg:4326")
    }
    if(is.null(crsto) || is.na(rgdal::CRSargs(crsto))) {
      warning("Projecting data to spherical mercator (epsg:3857)")
      crsto <- sp::CRS("+init=epsg:3857")
    }

    # if crs from and to are equivalent, return the original data

    if(crsfrom@projargs == crsto@projargs) {
      return(data)
    } else {
      coords <- coordinates(sp::spTransform(
        sp::SpatialPoints(
          sp::coordinates(cbind(data$x, data$y)), crsfrom), crsto))
      data$x <- coords[,1]
      data$y <- coords[,2]
      return(data)
    }


  },

  required_aes = c("x", "y")
)

#' Statisitc to project coordinates
#'
#' Projects coordinates using rgdal/sp. For use with \link{geom_spatial}. Takes params
#' \code{crsfrom} and \code{crsto}, both generated by \code{sp::CRS()} or \code{NULL}.
#' If \code{NULL}, \code{crsto} is assumed to be EPSG:3857 (Spherical Mercator) and
#' \code{crsto} is assumed to be EPSG:4326 (Lat/Lon).
"StatProject"


#' A ggplot2 geom for Spatial* objects
#'
#' A function returning a geom_* object based on the Spatial* input. Also will
#' happily project a regular \code{data.frame} provided x and y aesthetics are
#' specified. The result is a \code{geom_*} for use with ggplot2, with aesthetics
#' and other argumets passed on to that geom.
#'
#' @param data A \code{Spatial*} object or \code{data.frame}.
#' @param mapping A mapping as created by \code{aes()} or \code{aes_string()}
#' @param show.legend Logical describing the legend visibility.
#' @param inherit.aes Logical describing if aesthetics are inherited
#' @param position Passed on to geom_*
#' @param fromepsg The epsg code of the projection of the dataset (defaults to lat/lon or 4326 if
#'   not specified or the \code{data} does not specify a CRS)
#' @param toepsg The projection of the final plot (defaults to \code{fromepsg} if not specified
#'   or 3857 if \code{fromepsg} is not specified)
#' @param fromprojection Long form of \code{fromepsg}, a CRS object created by \code{sp::CRS()}
#' @param toprojection Long form of \code{toepsg}, a CRS object created by \code{sp::CRS()}
#' @param ... Agruments passed on to the \code{geom_*} (e.g. \code{lwd}, \code{fill}, etc.)
#'
#' @importFrom ggplot2 layer
#' @importFrom sp CRS
#' @export
#'
#' @examples
#' \donttest{
#' library(prettymapr)
#' ns <- searchbbox("Nova Scotia")
#' cities <- geocode(c("Wolfville, NS", "Windsor, NS", "Halifax, NS"))
#' ggplot(cities, aes(x=lon, y=lat)) + geom_spatial(toepsg=26920) + coord_fixed()
#' # default projection is Spherical Mercator (EPSG:3857)
#' ggplot(cities, aes(x=lon, y=lat)) + geom_spatial() + coord_fixed()
#'
#' # plot a number of spatial objects
#' data(longlake_marshdf, longlake_roadsdf, longlake_waterdf, longlake_depthdf,
#'      longlake_streamsdf, longlake_buildingsdf)
#' ggplot() +
#'   geom_spatial(longlake_waterdf, fill="lightblue") +
#'   geom_spatial(longlake_marshdf, fill="grey", alpha=0.5) +
#'   geom_spatial(longlake_streamsdf, col="lightblue") +
#'   geom_spatial(longlake_roadsdf, col="black") +
#'   geom_spatial(longlake_buildingsdf, pch=1, col="brown", size=0.25) +
#'   geom_spatial(longlake_depthdf, aes(col=DEPTH.M)) +
#'   facet_wrap(~NOTES)+
#'   coord_fixed()
#'
#'
#' library(maptools)
#' data(wrld_simpl)
#' ggplot() + geom_spatial(wrld_simpl)
#' }
#'
geom_spatial <- function(data=NULL, mapping = NULL, show.legend = TRUE, inherit.aes=TRUE,
                     position = "identity", fromepsg=NULL, toepsg=NULL,
                     fromprojection=NULL, toprojection=NULL, ...) {
  rgdal::CRSargs(CRS("+init=epsg:3857")) #hack to load rgdal namespace
  long <- NULL; rm(long); lat <- NULL; rm(lat) # hack for use of aes()
  group <- NULL; rm(group); x <-NULL; rm(x); y <-NULL; rm(y) # hack for use of aes()

  if(is.null(fromprojection) && !is.null(fromepsg)) {
    fromprojection <- sp::CRS(paste0("+init=epsg:", fromepsg))
  } else if(is.null(fromprojection) && methods::is(data, "Spatial")) {
    fromprojection <- data@proj4string
  }

  if(is.null(toprojection) && !is.null(toepsg)) {
    toprojection <- sp::CRS(paste0("+init=epsg:", toepsg))
  } else if(is.null(toprojection) && is.null(toepsg)) {
    toprojection <- fromprojection
  }

  # check type of input and return appropriate data, mapping, and geom
  if(methods::is(data, "SpatialPolygonsDataFrame")) {
    data@data$.id <- rownames(data@data)
    data.fort <- suppressMessages(ggplot2::fortify(data))
    data <- suppressWarnings(merge(data.fort, data@data, by.x="id", by.y=".id"))
    mapping <- c(ggplot2::aes(x=long, y=lat, group=group), mapping)
    class(mapping) <- "uneval"
    geom = "polygon"
  } else if(methods::is(data, "SpatialLinesDataFrame")) {
    data@data$.id <- rownames(data@data)
    data.fort <- suppressMessages(ggplot2::fortify(data, data@data))
    data <- suppressWarnings(merge(data.fort, data@data, by.x="id", by.y=".id"))
    mapping <- c(ggplot2::aes(x=long, y=lat, group=group), mapping)
    class(mapping) <- "uneval"
    geom = "path"
  } else if(methods::is(data, "SpatialPointsDataFrame")) {
    coords <- sp::coordinates(data)
    data <- data@data
    data$x <- coords[,1]
    data$y <- coords[,2]
    geom = "point"
    mapping <- c(ggplot2::aes(x=x, y=y), mapping)
    class(mapping) <- "uneval"
  } else if(methods::is(data, "SpatialPoints")) {
    coords <- sp::coordinates(data)
    data <- data.frame(x=coords[,1], y=coords[,2])
    if(!is.null(mapping)) warning("Overriding default mapping for SpatialPoints input")
    mapping <- ggplot2::aes(x=x, y=y)
    geom <- "point"
  } else if(methods::is(data, "SpatialPolygons")) {
    data <- ggplot2::fortify(data)
    if(!is.null(mapping)) warning("Overriding default mapping for SpatialPolygons input")
    mapping <- ggplot2::aes(x=long, y=lat, group=group)
    geom <- "polygon"
  } else if(methods::is(data, "SpatialLines")) {
    # bit of a hack, but fortify() won't take a SpatialLines
    data <- SpatialLinesDataFrame(data, data.frame(.dummy=1:length(data), row.names=row.names(data)))
    data@data$.id <- rownames(data@data)
    data.fort <- suppressMessages(ggplot2::fortify(data, data@data))
    data <- suppressWarnings(merge(data.fort, data@data, by.x="id", by.y=".id"))
    if(!is.null(mapping)) warning("Overriding default mapping for SpatialLines input")
    mapping <- ggplot2::aes(x=long, y=lat, group=group)
    geom <- "path"
  } else if(methods::is(data, "data.frame") || is.null(data)) {
    # data is a regular data frame, change nothing and ensure geom is 'point'
    geom <- "point"
  } else {
    stop("Cannot create spatial layer from object of class ", class(data))
  }

  layer(
    stat = StatProject, data = data, mapping = mapping, geom = geom,
    show.legend = show.legend, inherit.aes = inherit.aes, position = "identity",
    params=list(crsfrom=fromprojection, crsto=toprojection, ...)
  )
}
