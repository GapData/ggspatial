{
  "name": "ggspatial",
  "tagline": "A spatial data framework for ggplot2",
  "body": "ggspatial: Spatial data framework for ggplot2\r\n=============================================\r\n\r\nSpatial data plus the power of the `ggplot2` framework means easier mapping for all! Unfortunately facetting with `scales=\"free\"` doesn't work properly with `coord_fixed()`, so facetting is out if you want different extents in each facet window. But easy use of `ggplot2` with `sp`, `raster`, and basemaps through the `rosm` package is a go!\r\n\r\nInstallation\r\n------------\r\n\r\nThere are no plans to release `ggspatial` to CRAN until the facetting/`coord_fixed` bug is fixed in ggplot, but you can install using `devtools::install_github()`.\r\n\r\n``` r\r\ninstall.packages(\"devtools\") # if devtools isn't installed\r\ndevtools::install_github(\"paleolimbot/ggspatial\")\r\n```\r\n\r\nSpatial objects\r\n---------------\r\n\r\nMany (but not all) objects of type `Spatial*` can be used with `ggplot`, but syntax is inconsistent and results vary. This package introduces a single `geom_` for use with `Spatial*` objects (e.g. `SpatialPointsDataFrame`, `SpatialLinesDataFrame`, `SpatialPolygonsDataFrame`...essentially what you get when you use `rgdal::readOGR()` to read any kind of spatial data). A few datasets are included in the package as examples.\r\n\r\n``` r\r\nlibrary(ggspatial)\r\ndata(longlake_waterdf)\r\nggplot() + geom_spatial(longlake_waterdf) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-2-1.png)\r\n\r\nIf we examine `longlake_waterdf`, we can use the columns as aesthetics just as we would for a normal `data.frame`.\r\n\r\n``` r\r\nnames(longlake_waterdf)\r\n```\r\n\r\n    ##  [1] \"OBJECTID_1\" \"OBJECTID\"   \"FEAT_CODE\"  \"HID\"        \"PROVKEY\"   \r\n    ##  [6] \"ZVALUE\"     \"STARTDATE\"  \"ENDDATE\"    \"PRODUCT\"    \"SCALE\"     \r\n    ## [11] \"COLLECTOR\"  \"CAPTURE\"    \"PRODYEAR\"   \"PRODMONTH\"  \"X_Y_ACC\"   \r\n    ## [16] \"Z_ACC\"      \"MINZ\"       \"MAXZ\"       \"POLY_CLASS\" \"SHAPE_LENG\"\r\n    ## [21] \"SHAPE_LE_1\" \"label\"      \"area\"\r\n\r\n``` r\r\nggplot() + geom_spatial(longlake_waterdf, aes(fill=label)) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-3-1.png)\r\n\r\n``` r\r\nggplot() + geom_spatial(longlake_waterdf, aes(fill=label, col=area)) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-3-2.png)\r\n\r\nA more useful use of this may be to examine a depth survey from Long Lake I took on for my honours thesis.\r\n\r\n``` r\r\ndata(longlake_depthdf)\r\nggplot() + geom_spatial(longlake_waterdf[2,], fill=\"lightblue\") +\r\n  geom_spatial(longlake_depthdf, aes(col=DEPTH.M), size=2) + \r\n  scale_color_gradient(high=\"black\", low=\"#56B1F7\") + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-4-1.png)\r\n\r\nYou'll notice some bits are still a work in progress, but at least polygons with internal rings are rendered properly!\r\n\r\nProjections\r\n-----------\r\n\r\nIn our previous example the data were all in UTM zone 20 (epsg 26920), so we didn't have to worry about the data looking distorted because it's in lat/lon. For this example we're going to use the `wrld_simpl` dataset in the `maptools` package.\r\n\r\n``` r\r\nlibrary(maptools)\r\ndata(wrld_simpl)\r\nno_antarctica <- wrld_simpl[wrld_simpl$REGION != 0,] # antarctica complicates this example so...\r\nggplot() + geom_spatial(no_antarctica) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-5-1.png)\r\n\r\nSee? It's squished. Canada in particular looks all wrong, because our plot units are lat/lon which aren't distances. The number one way to look bad at a conference is to display an improperly projected map (depending who's looking...). We can fix this by passing a `toepsg` parameter (you can also pass a `CRS` object but that's more complicated).\r\n\r\n``` r\r\n# epsg:3857 is the google maps projection (spherical mercator)\r\nggplot() + geom_spatial(no_antarctica, toepsg=3857) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-6-1.png)\r\n\r\nYou can also project a regular old `data.frame` by using `geom_spatial()`. You have to specify for each one that you want it projected to epsg 3857 or it won't know.\r\n\r\n``` r\r\nlibrary(prettymapr)\r\ncities <- geocode(c(\"Halifax, NS\", \"Los Angeles, CA\", \"Auckland, NZ\", \"Moscow, RU\"))\r\nggplot() + geom_spatial(no_antarctica, toepsg=3857) + \r\n  geom_spatial(cities, aes(x=lon, y=lat, col=query), toepsg=3857) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-7-1.png)\r\n\r\nUnfortunately I haven't gotten around to the labeling bit, but it isn't too much of a stretch to make happen should somebody need it in the future.\r\n\r\nOSM Basemaps\r\n------------\r\n\r\nThanks to the brilliant creator of the `rosm` package, we can make a wrapper around the `osm.raster` function that lets us display a basemap behind whatever is on the screen. Note that this won't work if you mess with the projections too much, but if your data is in lat/lon and you're looking for a backdrop OR you just want an OSM map in a given projection, you can make it happen.\r\n\r\n``` r\r\nns <- searchbbox(\"Nova Scotia\")\r\nggplot() + geom_osm(ns) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-8-1.png)\r\n\r\nNote that it's not very pretty (you'll get much better results with `osm.plot()`), but it's at the very least a native solution to the raster problem. It's also no problem to project to any projection (provided all your original data is in lat/lon, which is the most common anyway)\r\n\r\n``` r\r\nggplot() + geom_osm(ns, epsg=26920) + coord_fixed() # plot in UTM\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-9-1.png)\r\n\r\nYou can also use `geom_osm()` with no arguments to provide a backdrop for your other data (again, can't stress enough that your un `geom_spatial`ed data should be in lat/lons if you're going to do this).\r\n\r\n``` r\r\ncities <- geocode(c(\"Wolfville, NS\", \"Windsor, NS\", \"Halifax, NS\", \"Lunenburg, NS\"))\r\nggplot(cities, aes(x=lon, y=lat, col=query)) + \r\n  geom_osm() + geom_spatial() + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-10-1.png)\r\n\r\nThe way ggplot works is pretty automatic, so there's not a whole lot I think that is possible on the zooming out front. If you're really worried about your OSM background, you should just use `osm.raster()` to get yourself a `RasterBrick` object (or write it to a file) and then use a `geom_spraster()` to plot it. Which brings me to...\r\n\r\nRaster objects\r\n--------------\r\n\r\nThe other game in town for spatial data in R is the `raster` package. You can read in raster datasets using the `raster::brick()` function with the filename as the argument.\r\n\r\n``` r\r\ndata(longlake_osm)\r\nggplot() + geom_spraster(longlake_osm) + coord_fixed()\r\n```\r\n\r\n![](README_files/figure-markdown_github/unnamed-chunk-11-1.png)\r\n\r\nThere's probably some nuances with raster datasets that I haven't thought about, but you can display specific bands and change the aesthetic (default is \"fill\", but \"alpha\" might also be appropriate). RGB datasets should work automatically (plus you can change which band is which using the `rgb` argument) but RGB with alpha probably won't work without some modification of the code.\r\n\r\nBugs\r\n----\r\n\r\nThe main bugs that need to be addressed in this package are:\r\n\r\n-   Raster RGBA support (important for hillshading)\r\n-   Facetting with `coord_fixed()` and `scales=\"free\"` would be a major asset, althoug this bug needs to be fixed in `ggplot` and not this package.\r\n-   Better integrate `coord_map()`, which is internal to `ggplot`\r\n\r\nThat's it! Enjoy!\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}